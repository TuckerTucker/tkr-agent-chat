# Project Definition for the Multi-Agent Chat System
app:
  name: "Tucker's Team - Multi-Agent Chat"
  author: "Tucker" # Assuming based on chat title
  role: "Developer" # Assuming
  description: "A web-based chat interface for interacting with multiple specialized AI agents using the Agent Development Kit (ADK)."
  taskboard:
    Board: TKR Multi-Agent Chat Implementation Plan
    ID: b829b5e1-d533-4ebb-81de-7b3336fc00ef
  github:
    user:"tuckertucker"
    repo:"tkr-agent-chat"
  version: "0.1.0"
  metadata:
    project_type: "multi_agent_chat_application"
    framework: "react"
    language: "typescript"
    last_updated: "2025-04-12" # Updated date
  documentation:
    ui_overview: "multiagent_chat_ui.md" # Link to the UI documentation
    adk_docs: "adk_overview.md"
    component_library: "https://storybook.js.org/" # Assuming Storybook usage
    api_docs: "agent_development_kit_documentation.md" # Link to ADK docs

architecture:
  server-client: "strict server/client architecture"
  patterns:
    state: "TanStack Query for managing server state cache, React state/context for local UI state (e.g., active session ID, theme)."
    # Updated data flow for server-side persistence
    data_flow: "UI Events -> API Call (React Query Mutation) / WebSocket -> API Gateway (DB Persistence, ADK Runner) -> WebSocket -> React Query Cache Invalidation -> UI Update"
    error_handling: "Error Boundaries per major UI section, toast notifications for transient errors, React Query error handling."
    component_development: "Storybook stories with shadcn/ui components"
  scalability:
    real_time:
      strategy: "WebSockets for message passing"
      rationale: "Essential for real-time chat updates between user and agents."
    state_management:
      strategy: "TanStack Query caching and background updates. WebSocket invalidates relevant queries."
      rationale: "Efficient server state management and synchronization."
  security:
    auth: # Assuming local development for now, placeholder
      provider: "None (Local Development)"
      strategy: "N/A"
    input_sanitization:
      strategy: "Sanitize user input on the client and server"
      rationale: "Prevent XSS attacks via chat messages."
  build:
    bundler: "Vite" # Modern alternative to Webpack/Next.js for SPAs
    optimization:
      code_splitting: "Route-based (if multiple pages) and component-based"
      tree_shaking: true
    dependencies:
      ui: "shadcn/ui"
      state: "@tanstack/react-query" # Changed from Zustand
      websockets: "native WebSocket API" # Using native WebSocket API
      forms: "React Hook Form (if complex forms needed)"
      component_library: "storybook"

development:
  framework: "React"
  language: "TypeScript"
  package_manager: "npm" # Or yarn/pnpm
  code_organization:
    structure:
      - "src/components/"
      - "src/components/ui/"      # shadcn/ui components
      - "src/stories/"           # Storybook stories
      - "src/hooks/"
      - "src/services/"          # WebSocket service, API calls
      # Removed src/store/
      - "src/types/"
      - "src/utils/"
      - "src/assets/"
    naming:
      components: "PascalCase"
      files: "kebab-case"
      constants: "SCREAMING_SNAKE_CASE"
      types: "PascalCase"
  testing:
    component:
      framework: "storybook"
      focus: ["component isolation", "visual regression", "interaction testing", "accessibility"]
      stories:
        structure: "src/**/*.stories.{ts,tsx}"
    unit:
      framework: "Vitest" # Modern alternative to Jest
      focus: ["store logic", "utility functions", "hook logic"]
    integration:
      framework: "React Testing Library"
      focus: ["component interactions", "state updates", "WebSocket message handling"]
    e2e:
      framework: "Playwright" # Modern alternative to Cypress
      critical_flows: ["sending/receiving messages", "switching chats", "agent interaction"]

theme: 
  screenshot: "/Volumes/tkr-riffic/tucker-home-folder/tkr-agent-chat/_planning/Screenshot 2025-04-11 at 12.28.06â€¯PM.png" # Based on the dark mode screenshot
  colors:
    primary: "blue-600" # Send button, user message
    secondary: "gray-700" # Agent message background
    accent: "emerald-500" # Example from template, maybe agent color?
    background: "gray-900" # Main chat area background
    sidebar_background: "gray-800"
    text_primary: "white"
    text_secondary: "gray-400"
    border: "gray-700"
    agent_chloe: "rgb(34 197 94)" # Green icon approx
    agent_Phil_Connors: "rgb(249 115 22)" # Orange icon approx (Renamed key)
  typography:
    font_family: "sans-serif" # Default system font
    base_size: "14px" # Typical for chat interfaces
  spacing:
    small: "4px"
    medium: "8px"
    large: "16px"
    xl: "24px"

agents:
  architecture: "Each agent is a self-contained Python module following ADK conventions, designed for modularity, testability, and easy integration."
  directory_structure: |
    agents/
      base_agent.py            # Shared BaseAgent class for all agents
      agent_name/
        README.md                # Agent documentation and usage
        pyproject.toml           # Python package metadata (or setup.py)
        src/
          agent.py               # Core agent logic (inherits from agents/base_agent.py)
          config.py              # Agent config: id, name, description, color, capabilities, etc.
          index.py               # Entry point/factory for agent instantiation
          prompt.py              # Modular prompt templates and logic
          tools/
            __init__.py
            ...                  # Individual tool implementations (Python modules/classes)
          tests/
            __init__.py
            test_agent.py        # Unit tests for agent and tools
          assets/                # Static assets (e.g., avatar image file)
  config_and_metadata:
    - id: "Unique agent identifier"
    - name: "Display name"
    - description: "Short description of the agent"
    - color: "UI theming color (Hex format, e.g., #RRGGBB)"
    - capabilities: "List of supported features/tools"
    - optional: ["icon_path (path to avatar file in assets/)", "version"]
  tools: "Each agent has its own tools/ directory for modular tool implementations. Tools are registered with the agent via the tools property."
  prompts: "Prompt logic is modular and file-based (prompt.py), supporting easy customization and extension."
  testing: "Unit tests are required for agent logic and tools, located in tests/."
  integration: # Updated for ADK Streaming Model
    runner: "Agents are loaded by the API Gateway and executed using the google-adk Runner."
    ui: "Agent metadata is exposed via a REST endpoint (/api/v1/agents). Chat interaction occurs via a direct WebSocket connection per agent (/ws/v1/chat/{session_id}/{agent_id}) managed by the API Gateway, which uses the ADK Runner internally."
    events: "Agent responses (text chunks, turn completion) are streamed directly to the UI via the WebSocket connection."
  best_practices:
    - "Keep each agent self-contained and modular."
    - "Use clear, documented configuration for UI integration."
    - "Write unit tests for all core logic and tools."
    - "Document agent capabilities and usage in README.md."
    - "Prefer composition (tools, prompts) over inheritance for extensibility."

  mcp_tools:
    architecture: |
      MCP tools are implemented using the Python SDK and included in each agent's tools/ directory.
      - Prefer an MCP server per agent for modularity and isolation.
      - For lightweight or tightly-coupled agents, a shared server may be considered.
    interface:
      options:
        - stateless_function: "Simple, easy to test, no side effects. Cannot maintain state between invocations."
        - class: "Encapsulates logic, easy to extend, supports dependency injection. Still stateless unless state is persisted externally."
        - persistent_object: "Maintains state across invocations (e.g., cache, session). Use only when necessary; harder to test."
      recommendation: "Default to stateless functions or lightweight classes. Use persistent objects only if stateful behavior is required."
    discovery: "Tools are auto-registered by scanning the tools/ directory at agent startup. Use naming conventions or decorators to mark tool entry points."
    config: "Tools are configured per agent and do not support runtime configuration by default."
    invocation: "Tools are invoked internally by the agent logic (e.g., via ADK's function calling or direct calls), not via MCP." # Updated invocation
    error_handling: |
      - Catch and handle all exceptions within tool logic.
      - Return structured error responses via MCP protocol (error code, message).
      - Avoid leaking stack traces or sensitive info to the client.
    logging: |
      - Log tool invocations, errors, and important events using Python's logging module.
      - Use per-agent log files or structured logging for easier debugging.
    testing: |
      - Write unit tests for each tool in tools/tests/ or tests/.
      - Test both normal and error cases.
      - Use mocks for external dependencies.

# End of project definition
